{"version":3,"file":"index-es.min.js","sources":["../src/jsonpath.js"],"sourcesContent":["/* eslint-disable prefer-named-capture-group */\n// Disabled `prefer-named-capture-group` due to https://github.com/babel/babel/issues/8951#issuecomment-508045524\n// Only Node.JS has a process variable that is of [[Class]] process\nconst supportsNodeVM = function () {\n    try {\n        return Object.prototype.toString.call(\n            global.process\n        ) === '[object process]';\n    } catch (e) {\n        return false;\n    }\n};\nconst allowedResultTypes = [\n    'value', 'path', 'pointer', 'parent', 'parentProperty', 'all'\n];\nconst {hasOwnProperty: hasOwnProp} = Object.prototype;\n\n/**\n* @typedef {null|boolean|number|string|PlainObject|GenericArray} JSONObject\n*/\n\n/**\n* @callback ConditionCallback\n* @param item\n* @returns {boolean}\n*/\n\n/**\n * Copy items out of one array into another.\n * @param {GenericArray} source Array with items to copy\n * @param {GenericArray} target Array to which to copy\n * @param {ConditionCallback} conditionCb Callback passed the current item;\n *     will move item if evaluates to `true`\n * @returns {undefined}\n */\nconst moveToAnotherArray = function (source, target, conditionCb) {\n    const il = source.length;\n    for (let i = 0; i < il; i++) {\n        const item = source[i];\n        if (conditionCb(item)) {\n            target.push(source.splice(i--, 1)[0]);\n        }\n    }\n};\n\nconst vm = supportsNodeVM()\n    ? require('vm')\n    : {\n        /**\n         * @param {string} expr Expression to evaluate\n         * @param {PlainObject} context Object whose items will be added\n         *   to evaluation\n         * @returns {any} Result of evaluated code\n         */\n        runInNewContext (expr, context) {\n            const keys = Object.keys(context);\n            const funcs = [];\n            moveToAnotherArray(keys, funcs, (key) => {\n                return typeof context[key] === 'function';\n            });\n            // Todo[engine:node@>=8]: Use the next line instead of the\n            //  succeeding\n            // const values = Object.values(context);\n            const values = keys.map((vr, i) => {\n                return context[vr];\n            });\n            const funcString = funcs.reduce((s, func) => {\n                let fString = context[func].toString();\n                if (!(/function/u).exec(fString)) {\n                    fString = 'function ' + fString;\n                }\n                return 'var ' + func + '=' + fString + ';' + s;\n            }, '');\n\n            expr = funcString + expr;\n\n            // Mitigate http://perfectionkills.com/global-eval-what-are-the-options/#new_function\n            if (!expr.match(/(['\"])use strict\\1/u) &&\n                !keys.includes('arguments')\n            ) {\n                expr = 'var arguments = undefined;' + expr;\n            }\n\n            // Remove last semi so `return` will be inserted before\n            //  the previous one instead, allowing for the return\n            //  of a bare ending expression\n            expr = expr.replace(/;\\s*$/u, '');\n\n            // Insert `return`\n            const lastStatementEnd = expr.lastIndexOf(';');\n            const code = (lastStatementEnd > -1\n                ? expr.slice(0, lastStatementEnd + 1) +\n                    ' return ' + expr.slice(lastStatementEnd + 1)\n                : ' return ' + expr);\n\n            // eslint-disable-next-line no-new-func\n            return (new Function(...keys, code))(...values);\n        }\n    };\n\n/**\n * Copies array and then pushes item into it.\n * @param {GenericArray} arr Array to copy and into which to push\n * @param {any} item Array item to add (to end)\n * @returns {GenericArray} Copy of the original array\n */\nfunction push (arr, item) {\n    arr = arr.slice();\n    arr.push(item);\n    return arr;\n}\n/**\n * Copies array and then unshifts item into it.\n * @param {any} item Array item to add (to beginning)\n * @param {GenericArray} arr Array to copy and into which to unshift\n * @returns {GenericArray} Copy of the original array\n */\nfunction unshift (item, arr) {\n    arr = arr.slice();\n    arr.unshift(item);\n    return arr;\n}\n\n/**\n * Caught when JSONPath is used without `new` but rethrown if with `new`\n * @extends Error\n */\nclass NewError extends Error {\n    /**\n     * @param {any} value The evaluated scalar value\n     */\n    constructor (value) {\n        super(\n            'JSONPath should not be called with \"new\" (it prevents return ' +\n            'of (unwrapped) scalar values)'\n        );\n        this.avoidNew = true;\n        this.value = value;\n        this.name = 'NewError';\n    }\n}\n\n/**\n* @typedef {PlainObject} ReturnObject\n* @property {string} path\n* @property {JSONObject} value\n* @property {PlainObject|GenericArray} parent\n* @property {string} parentProperty\n*/\n\n/**\n* @callback JSONPathCallback\n* @param {string|PlainObject} preferredOutput\n* @param {\"value\"|\"property\"} type\n* @param {ReturnObject} fullRetObj\n* @returns {void}\n*/\n\n/**\n* @callback OtherTypeCallback\n* @param {JSONObject} val\n* @param {string} path\n* @param {PlainObject|GenericArray} parent\n* @param {string} parentPropName\n* @returns {boolean}\n*/\n\n/**\n * @typedef {PlainObject} JSONPathOptions\n * @property {JSON} json\n * @property {string|string[]} path\n * @property {\"value\"|\"path\"|\"pointer\"|\"parent\"|\"parentProperty\"|\"all\"}\n *   [resultType=\"value\"]\n * @property {boolean} [flatten=false]\n * @property {boolean} [wrap=true]\n * @property {PlainObject} [sandbox={}]\n * @property {boolean} [preventEval=false]\n * @property {PlainObject|GenericArray|null} [parent=null]\n * @property {string|null} [parentProperty=null]\n * @property {JSONPathCallback} [callback]\n * @property {OtherTypeCallback} [otherTypeCallback] Defaults to\n *   function which throws on encountering `@other`\n * @property {boolean} [autostart=true]\n */\n\n/**\n * @param {string|JSONPathOptions} opts If a string, will be treated as `expr`\n * @param {string} [expr] JSON path to evaluate\n * @param {JSON} [obj] JSON object to evaluate against\n * @param {JSONPathCallback} [callback] Passed 3 arguments: 1) desired payload\n *     per `resultType`, 2) `\"value\"|\"property\"`, 3) Full returned object with\n *     all payloads\n * @param {OtherTypeCallback} [otherTypeCallback] If `@other()` is at the end\n *   of one's query, this will be invoked with the value of the item, its\n *   path, its parent, and its parent's property name, and it should return\n *   a boolean indicating whether the supplied value belongs to the \"other\"\n *   type or not (or it may handle transformations and return `false`).\n * @returns {JSONPath}\n * @class\n */\nfunction JSONPath (opts, expr, obj, callback, otherTypeCallback) {\n    // eslint-disable-next-line no-restricted-syntax\n    if (!(this instanceof JSONPath)) {\n        try {\n            return new JSONPath(opts, expr, obj, callback, otherTypeCallback);\n        } catch (e) {\n            if (!e.avoidNew) {\n                throw e;\n            }\n            return e.value;\n        }\n    }\n\n    if (typeof opts === 'string') {\n        otherTypeCallback = callback;\n        callback = obj;\n        obj = expr;\n        expr = opts;\n        opts = null;\n    }\n    const optObj = opts && typeof opts === 'object';\n    opts = opts || {};\n    this.json = opts.json || obj;\n    this.path = opts.path || expr;\n    this.resultType = (opts.resultType && opts.resultType.toLowerCase()) ||\n        'value';\n    this.flatten = opts.flatten || false;\n    this.wrap = hasOwnProp.call(opts, 'wrap') ? opts.wrap : true;\n    this.sandbox = opts.sandbox || {};\n    this.preventEval = opts.preventEval || false;\n    this.parent = opts.parent || null;\n    this.parentProperty = opts.parentProperty || null;\n    this.callback = opts.callback || callback || null;\n    this.otherTypeCallback = opts.otherTypeCallback ||\n        otherTypeCallback ||\n        function () {\n            throw new TypeError(\n                'You must supply an otherTypeCallback callback option ' +\n                'with the @other() operator.'\n            );\n        };\n\n    if (opts.autostart !== false) {\n        const args = {\n            path: (optObj ? opts.path : expr)\n        };\n        if (!optObj) {\n            args.json = obj;\n        } else if ('json' in opts) {\n            args.json = opts.json;\n        }\n        const ret = this.evaluate(args);\n        if (!ret || typeof ret !== 'object') {\n            throw new NewError(ret);\n        }\n        return ret;\n    }\n}\n\n// PUBLIC METHODS\nJSONPath.prototype.evaluate = function (\n    expr, json, callback, otherTypeCallback\n) {\n    const that = this;\n    let currParent = this.parent,\n        currParentProperty = this.parentProperty;\n    let {flatten, wrap} = this;\n\n    this.currResultType = this.resultType;\n    this.currPreventEval = this.preventEval;\n    this.currSandbox = this.sandbox;\n    callback = callback || this.callback;\n    this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;\n\n    json = json || this.json;\n    expr = expr || this.path;\n    if (expr && typeof expr === 'object') {\n        if (!expr.path) {\n            throw new TypeError(\n                'You must supply a \"path\" property when providing an object ' +\n                'argument to JSONPath.evaluate().'\n            );\n        }\n        if (!('json' in expr)) {\n            throw new TypeError(\n                'You must supply a \"json\" property when providing an object ' +\n                'argument to JSONPath.evaluate().'\n            );\n        }\n        json = hasOwnProp.call(expr, 'json') ? expr.json : json;\n        flatten = hasOwnProp.call(expr, 'flatten') ? expr.flatten : flatten;\n        this.currResultType = hasOwnProp.call(expr, 'resultType')\n            ? expr.resultType\n            : this.currResultType;\n        this.currSandbox = hasOwnProp.call(expr, 'sandbox')\n            ? expr.sandbox\n            : this.currSandbox;\n        wrap = hasOwnProp.call(expr, 'wrap') ? expr.wrap : wrap;\n        this.currPreventEval = hasOwnProp.call(expr, 'preventEval')\n            ? expr.preventEval\n            : this.currPreventEval;\n        callback = hasOwnProp.call(expr, 'callback') ? expr.callback : callback;\n        this.currOtherTypeCallback = hasOwnProp.call(expr, 'otherTypeCallback')\n            ? expr.otherTypeCallback\n            : this.currOtherTypeCallback;\n        currParent = hasOwnProp.call(expr, 'parent') ? expr.parent : currParent;\n        currParentProperty = hasOwnProp.call(expr, 'parentProperty')\n            ? expr.parentProperty\n            : currParentProperty;\n        expr = expr.path;\n    }\n    currParent = currParent || null;\n    currParentProperty = currParentProperty || null;\n\n    if (Array.isArray(expr)) {\n        expr = JSONPath.toPathString(expr);\n    }\n    if (!expr || !json || !allowedResultTypes.includes(this.currResultType)) {\n        return undefined;\n    }\n    this._obj = json;\n\n    const exprList = JSONPath.toPathArray(expr);\n    if (exprList[0] === '$' && exprList.length > 1) { exprList.shift(); }\n    this._hasParentSelector = null;\n    const result = this\n        ._trace(exprList, json, ['$'], currParent, currParentProperty, callback)\n        .filter(function (ea) { return ea && !ea.isParentSelector; });\n\n    if (!result.length) { return wrap ? [] : undefined; }\n    if (!wrap && this.isSingularResult(result, exprList)) {\n        return this._getPreferredOutput(result[0]);\n    }\n    return result.reduce(function (rslt, ea) {\n        const valOrPath = that._getPreferredOutput(ea);\n        if (flatten && Array.isArray(valOrPath)) {\n            rslt = rslt.concat(valOrPath);\n        } else {\n            rslt.push(valOrPath);\n        }\n        return rslt;\n    }, []);\n};\n\n// PRIVATE METHODS\n\nJSONPath.prototype._getPreferredOutput = function (ea) {\n    const resultType = this.currResultType;\n    switch (resultType) {\n    default:\n        throw new TypeError('Unknown result type');\n    case 'all':\n        ea.pointer = JSONPath.toPointer(ea.path);\n        ea.path = typeof ea.path === 'string'\n            ? ea.path\n            : JSONPath.toPathString(ea.path);\n        return ea;\n    case 'value': case 'parent': case 'parentProperty':\n        return ea[resultType];\n    case 'path':\n        return JSONPath.toPathString(ea[resultType]);\n    case 'pointer':\n        return JSONPath.toPointer(ea.path);\n    }\n};\n/**\n * Detect filter expressions.\n * @param {string}loc\n * @returns {boolean}\n */\nJSONPath.prototype.isFilterExpr = function (loc) {\n    return loc.indexOf('?(') === 0;\n};\n/**\n * Detects operators in the expression list that require an array result.\n * an array of results. If no such operator exists, the result\n * will be treated as a singular value.\n *\n * For example, the following paths reference singular results:\n *   \"store.book[0]\" - specific book\n *   \"store.bicycle.red\" - single property of a single object\n *\n * Conversely, the following paths will always result in an array,\n * because they can generate multiple results depending on the dataset:\n *   $.store.book[0][category,author] - category,author will return 2 values\n *   $..book - \"..\" will recurse through the store object\n *   $.store.book[1:2] - indicates a range within the array\n *   $.store.book[*] - wild card indicates multiple results\n *   $.store.book[?(@.isbn)] - filtering\n */\n/**\n * @param {PlainObject} result - json path result\n * @param {array} exprList - array of json path expressions\n * @returns {boolean}\n */\nJSONPath.prototype.isSingularResult = function (result, exprList) {\n    return (result.length === 1 &&\n             !exprList.includes('*') &&\n             !exprList.includes('..') &&\n              exprList.every((loc) => !this.isFilterExpr(loc)) &&\n              exprList.every((loc) => !loc.includes(',')) &&\n              exprList.every((loc) => !loc.includes(':')));\n};\n\nJSONPath.prototype._handleCallback = function (fullRetObj, callback, type) {\n    if (callback) {\n        const preferredOutput = this._getPreferredOutput(fullRetObj);\n        fullRetObj.path = typeof fullRetObj.path === 'string'\n            ? fullRetObj.path\n            : JSONPath.toPathString(fullRetObj.path);\n        // eslint-disable-next-line callback-return\n        callback(preferredOutput, type, fullRetObj);\n    }\n};\n\n/**\n *\n * @param {string} expr\n * @param {JSONObject} val\n * @param {string} path\n * @param {PlainObject|GenericArray} parent\n * @param {string} parentPropName\n * @param {JSONPathCallback} callback\n * @param {boolean} literalPriority\n * @returns {ReturnObject|ReturnObject[]}\n */\nJSONPath.prototype._trace = function (\n    expr, val, path, parent, parentPropName, callback, literalPriority\n) {\n    // No expr to follow? return path and value as the result of\n    //  this trace branch\n    let retObj;\n    const that = this;\n    if (!expr.length) {\n        retObj = {path, value: val, parent, parentProperty: parentPropName};\n        this._handleCallback(retObj, callback, 'value');\n        return retObj;\n    }\n\n    const loc = expr[0], x = expr.slice(1);\n\n    // We need to gather the return value of recursive trace calls in order to\n    // do the parent sel computation.\n    const ret = [];\n    /**\n     *\n     * @param {ReturnObject|ReturnObject[]} elems\n     * @returns {void}\n     */\n    function addRet (elems) {\n        if (Array.isArray(elems)) {\n            // This was causing excessive stack size in Node (with or\n            //  without Babel) against our performance test:\n            //  `ret.push(...elems);`\n            elems.forEach((t) => {\n                ret.push(t);\n            });\n        } else {\n            ret.push(elems);\n        }\n    }\n    if ((typeof loc !== 'string' || literalPriority) && val &&\n        hasOwnProp.call(val, loc)\n    ) { // simple case--directly follow property\n        addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback));\n    } else if (loc === '*') { // all child properties\n        this._walk(\n            loc, x, val, path, parent, parentPropName, callback,\n            function (m, l, _x, v, p, par, pr, cb) {\n                addRet(that._trace(unshift(m, _x), v, p, par, pr, cb, true));\n            }\n        );\n    } else if (loc === '..') { // all descendent parent properties\n        // Check remaining expression with val's immediate children\n        addRet(\n            this._trace(x, val, path, parent, parentPropName, callback)\n        );\n        this._walk(\n            loc, x, val, path, parent, parentPropName, callback,\n            function (m, l, _x, v, p, par, pr, cb) {\n                // We don't join m and x here because we only want parents,\n                //   not scalar values\n                if (typeof v[m] === 'object') {\n                    // Keep going with recursive descent on val's\n                    //   object children\n                    addRet(that._trace(\n                        unshift(l, _x), v[m], push(p, m), v, m, cb\n                    ));\n                }\n            }\n        );\n    // The parent sel computation is handled in the frame above using the\n    // ancestor object of val\n    } else if (loc === '^') {\n        // This is not a final endpoint, so we do not invoke the callback here\n        this._hasParentSelector = true;\n        return path.length\n            ? {\n                path: path.slice(0, -1),\n                expr: x,\n                isParentSelector: true\n            }\n            : [];\n    } else if (loc === '~') { // property name\n        retObj = {\n            path: push(path, loc),\n            value: parentPropName,\n            parent,\n            parentProperty: null\n        };\n        this._handleCallback(retObj, callback, 'property');\n        return retObj;\n    } else if (loc === '$') { // root only\n        addRet(this._trace(x, val, path, null, null, callback));\n    } else if ((/^(-?\\d*):(-?\\d*):?(\\d*)$/u).test(loc)) { // [start:end:step]  Python slice syntax\n        addRet(\n            this._slice(loc, x, val, path, parent, parentPropName, callback)\n        );\n    } else if (this.isFilterExpr(loc)) { // [?(expr)] (filtering)\n        if (this.currPreventEval) {\n            throw new Error('Eval [?(expr)] prevented in JSONPath expression.');\n        }\n        this._walk(\n            loc, x, val, path, parent, parentPropName, callback,\n            function (m, l, _x, v, p, par, pr, cb) {\n                if (that._eval(l.replace(/^\\?\\((.*?)\\)$/u, '$1'), v[m], m, p, par, pr)) {\n                    addRet(that._trace(unshift(m, _x), v, p, par, pr, cb));\n                }\n            }\n        );\n    } else if (loc[0] === '(') { // [(expr)] (dynamic property/index)\n        if (this.currPreventEval) {\n            throw new Error('Eval [(expr)] prevented in JSONPath expression.');\n        }\n        // As this will resolve to a property name (but we don't know it\n        //  yet), property and parent information is relative to the\n        //  parent of the property to which this expression will resolve\n        addRet(this._trace(unshift(\n            this._eval(\n                loc, val, path[path.length - 1],\n                path.slice(0, -1), parent, parentPropName\n            ),\n            x\n        ), val, path, parent, parentPropName, callback));\n    } else if (loc[0] === '@') { // value type: @boolean(), etc.\n        let addType = false;\n        const valueType = loc.slice(1, -2);\n        switch (valueType) {\n        default:\n            throw new TypeError('Unknown value type ' + valueType);\n        case 'scalar':\n            if (!val || !(['object', 'function'].includes(typeof val))) {\n                addType = true;\n            }\n            break;\n        case 'boolean': case 'string': case 'undefined': case 'function':\n            // eslint-disable-next-line valid-typeof\n            if (typeof val === valueType) {\n                addType = true;\n            }\n            break;\n        case 'number':\n            // eslint-disable-next-line valid-typeof\n            if (typeof val === valueType && isFinite(val)) {\n                addType = true;\n            }\n            break;\n        case 'nonFinite':\n            if (typeof val === 'number' && !isFinite(val)) {\n                addType = true;\n            }\n            break;\n        case 'object':\n            // eslint-disable-next-line valid-typeof\n            if (val && typeof val === valueType) {\n                addType = true;\n            }\n            break;\n        case 'array':\n            if (Array.isArray(val)) {\n                addType = true;\n            }\n            break;\n        case 'other':\n            addType = this.currOtherTypeCallback(\n                val, path, parent, parentPropName\n            );\n            break;\n        case 'integer':\n            if (val === Number(val) && isFinite(val) && !(val % 1)) {\n                addType = true;\n            }\n            break;\n        case 'null':\n            if (val === null) {\n                addType = true;\n            }\n            break;\n        }\n        if (addType) {\n            retObj = {path, value: val, parent, parentProperty: parentPropName};\n            this._handleCallback(retObj, callback, 'value');\n            return retObj;\n        }\n    // `-escaped property\n    } else if (loc[0] === '`' && val && hasOwnProp.call(val, loc.slice(1))) {\n        const locProp = loc.slice(1);\n        addRet(this._trace(\n            x, val[locProp], push(path, locProp), val, locProp, callback, true\n        ));\n    } else if (loc.includes(',')) { // [name1,name2,...]\n        const parts = loc.split(',');\n        for (const part of parts) {\n            addRet(this._trace(\n                unshift(part, x), val, path, parent, parentPropName, callback\n            ));\n        }\n    // simple case--directly follow property\n    } else if (!literalPriority && val && hasOwnProp.call(val, loc)) {\n        addRet(\n            this._trace(x, val[loc], push(path, loc), val, loc, callback, true)\n        );\n    }\n\n    // We check the resulting values for parent selections. For parent\n    // selections we discard the value object and continue the trace with the\n    // current val object\n    if (this._hasParentSelector) {\n        for (let t = 0; t < ret.length; t++) {\n            const rett = ret[t];\n            if (rett.isParentSelector) {\n                const tmp = that._trace(\n                    rett.expr, val, rett.path, parent, parentPropName, callback\n                );\n                if (Array.isArray(tmp)) {\n                    ret[t] = tmp[0];\n                    const tl = tmp.length;\n                    for (let tt = 1; tt < tl; tt++) {\n                        t++;\n                        ret.splice(t, 0, tmp[tt]);\n                    }\n                } else {\n                    ret[t] = tmp;\n                }\n            }\n        }\n    }\n    return ret;\n};\n\nJSONPath.prototype._walk = function (\n    loc, expr, val, path, parent, parentPropName, callback, f\n) {\n    if (Array.isArray(val)) {\n        const n = val.length;\n        for (let i = 0; i < n; i++) {\n            f(i, loc, expr, val, path, parent, parentPropName, callback);\n        }\n    } else if (typeof val === 'object') {\n        for (const m in val) {\n            if (hasOwnProp.call(val, m)) {\n                f(m, loc, expr, val, path, parent, parentPropName, callback);\n            }\n        }\n    }\n};\n\nJSONPath.prototype._slice = function (\n    loc, expr, val, path, parent, parentPropName, callback\n) {\n    if (!Array.isArray(val)) { return undefined; }\n    const len = val.length, parts = loc.split(':'),\n        step = (parts[2] && parseInt(parts[2])) || 1;\n    let start = (parts[0] && parseInt(parts[0])) || 0,\n        end = (parts[1] && parseInt(parts[1])) || len;\n    start = (start < 0) ? Math.max(0, start + len) : Math.min(len, start);\n    end = (end < 0) ? Math.max(0, end + len) : Math.min(len, end);\n    const ret = [];\n    for (let i = start; i < end; i += step) {\n        const tmp = this._trace(\n            unshift(i, expr), val, path, parent, parentPropName, callback\n        );\n        if (Array.isArray(tmp)) {\n            // This was causing excessive stack size in Node (with or\n            //  without Babel) against our performance test: `ret.push(...tmp);`\n            tmp.forEach((t) => {\n                ret.push(t);\n            });\n        } else {\n            ret.push(tmp);\n        }\n    }\n    return ret;\n};\n\nJSONPath.prototype._eval = function (\n    code, _v, _vname, path, parent, parentPropName\n) {\n    if (!this._obj || !_v) { return false; }\n    if (code.includes('@parentProperty')) {\n        this.currSandbox._$_parentProperty = parentPropName;\n        code = code.replace(/@parentProperty/gu, '_$_parentProperty');\n    }\n    if (code.includes('@parent')) {\n        this.currSandbox._$_parent = parent;\n        code = code.replace(/@parent/gu, '_$_parent');\n    }\n    if (code.includes('@property')) {\n        this.currSandbox._$_property = _vname;\n        code = code.replace(/@property/gu, '_$_property');\n    }\n    if (code.includes('@path')) {\n        this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));\n        code = code.replace(/@path/gu, '_$_path');\n    }\n    if (code.includes('@root')) {\n        this.currSandbox._$_root = this.json;\n        code = code.replace(/@root/gu, '_$_root');\n    }\n    if (code.match(/@([.\\s)[])/u)) {\n        this.currSandbox._$_v = _v;\n        code = code.replace(/@([.\\s)[])/gu, '_$_v$1');\n    }\n    try {\n        return vm.runInNewContext(code, this.currSandbox);\n    } catch (e) {\n        // eslint-disable-next-line no-console\n        console.log(e);\n        throw new Error('jsonPath: ' + e.message + ': ' + code);\n    }\n};\n\n// PUBLIC CLASS PROPERTIES AND METHODS\n\n// Could store the cache object itself\nJSONPath.cache = {};\n\n/**\n * @param {string[]} pathArr Array to convert\n * @returns {string} The path string\n */\nJSONPath.toPathString = function (pathArr) {\n    const x = pathArr, n = x.length;\n    let p = '$';\n    for (let i = 1; i < n; i++) {\n        if (!(/^(~|\\^|@.*?\\(\\))$/u).test(x[i])) {\n            p += (/^[0-9*]+$/u).test(x[i]) ? ('[' + x[i] + ']') : (\"['\" + x[i] + \"']\");\n        }\n    }\n    return p;\n};\n\n/**\n * @param {string} pointer JSON Path\n * @returns {string} JSON Pointer\n */\nJSONPath.toPointer = function (pointer) {\n    const x = pointer, n = x.length;\n    let p = '';\n    for (let i = 1; i < n; i++) {\n        if (!(/^(~|\\^|@.*?\\(\\))$/u).test(x[i])) {\n            p += '/' + x[i].toString()\n                .replace(/~/gu, '~0')\n                .replace(/\\//gu, '~1');\n        }\n    }\n    return p;\n};\n\n/**\n * @param {string} expr Expression to convert\n * @returns {string[]}\n */\nJSONPath.toPathArray = function (expr) {\n    const {cache} = JSONPath;\n    if (cache[expr]) { return cache[expr].concat(); }\n    const subx = [];\n    const normalized = expr\n        // Properties\n        .replace(\n            /@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\\(\\)/gu,\n            ';$&;'\n        )\n        // Parenthetical evaluations (filtering and otherwise), directly\n        //   within brackets or single quotes\n        .replace(/[['](\\??\\(.*?\\))[\\]']/gu, function ($0, $1) {\n            return '[#' + (subx.push($1) - 1) + ']';\n        })\n        // Escape periods and tildes within properties\n        .replace(/\\['([^'\\]]*)'\\]/gu, function ($0, prop) {\n            return \"['\" + prop\n                .replace(/\\./gu, '%@%')\n                .replace(/~/gu, '%%@@%%') +\n                \"']\";\n        })\n        // Properties operator\n        .replace(/~/gu, ';~;')\n        // Split by property boundaries\n        .replace(/'?\\.'?(?![^[]*\\])|\\['?/gu, ';')\n        // Reinsert periods within properties\n        .replace(/%@%/gu, '.')\n        // Reinsert tildes within properties\n        .replace(/%%@@%%/gu, '~')\n        // Parent\n        .replace(/(?:;)?(\\^+)(?:;)?/gu, function ($0, ups) {\n            return ';' + ups.split('').join(';') + ';';\n        })\n        // Descendents\n        .replace(/;;;|;;/gu, ';..;')\n        // Remove trailing\n        .replace(/;$|'?\\]|'$/gu, '');\n\n    const exprList = normalized.split(';').map(function (exp) {\n        const match = exp.match(/#(\\d+)/u);\n        return !match || !match[1] ? exp : subx[match[1]];\n    });\n    cache[expr] = exprList;\n    return cache[expr];\n};\n\nexport {JSONPath};\n"],"names":["allowedResultTypes","hasOwnProp","Object","prototype","hasOwnProperty","vm","toString","call","global","process","e","supportsNodeVM","require","runInNewContext","expr","context","keys","funcs","source","target","conditionCb","il","length","i","push","splice","moveToAnotherArray","key","values","map","vr","reduce","s","func","fString","exec","match","includes","lastStatementEnd","replace","lastIndexOf","code","slice","_construct","Function","arr","item","unshift","NewError","value","avoidNew","name","Error","JSONPath","opts","obj","callback","otherTypeCallback","this","optObj","_typeof","json","path","resultType","toLowerCase","flatten","wrap","sandbox","preventEval","parent","parentProperty","TypeError","autostart","args","ret","evaluate","that","currParent","currParentProperty","currResultType","currPreventEval","currSandbox","currOtherTypeCallback","Array","isArray","toPathString","_obj","exprList","toPathArray","shift","_hasParentSelector","result","_trace","filter","ea","isParentSelector","isSingularResult","_getPreferredOutput","rslt","valOrPath","concat","undefined","pointer","toPointer","isFilterExpr","loc","indexOf","every","_this2","_handleCallback","fullRetObj","type","preferredOutput","val","parentPropName","literalPriority","retObj","x","addRet","elems","forEach","t","_walk","m","l","_x","v","p","par","pr","cb","test","_slice","_eval","addType","valueType","isFinite","Number","locProp","parts","split","part","rett","tmp","tl","tt","f","n","len","step","parseInt","start","end","Math","max","min","_v","_vname","_$_parentProperty","_$_parent","_$_property","_$_path","_$_root","_$_v","console","log","message","cache","pathArr","subx","$0","$1","prop","ups","join","exp"],"mappings":"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"}